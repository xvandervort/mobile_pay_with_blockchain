4/1
  Blocks controller now allows drill down into blocks and assopciated transactions.
  Note: I think I stored the wrong thing in the block hash. either that or I need to store the total proof of work, not just the nonce. Whatever. The prototype is now done and I can write the ID.

3/28
  Time to start work on the miner. (DONE)
  But first, fix the bizarreness with the payments list test. (DONE)
  What does a miner do? It builds blocks. Period. transmitting and receiving is an issue for the distributed system, which I'm not doing for here.

3/27
  Repaired (more or less) block hash by adding in timestamp and previous block hash. 

3/27 Discussion
  6 confirmations (blocks) on top of a transaction
  Currently doing no error checking. If the same invoice image is sent more than once, you should fail.
  Transactions need a type. The "coinbase" type contains no image. It's intended to (in the future) support mining. The standard types are invoices (where permission may be requested) or reciepts (after the fact). Receipts do not need permission feedback, though business rules may still be applied to determine whether they are accepted or rejected. An audit type is also possible. This would basically just verify some previous transaction. I don't know what the value of that is.
  Business rules can also be applied to what transactions are included in a block.

3/26
  Had to rearrange fields between block and block_worker and set block to delegate most fields to block_worker, in order to avoid duplication. This means that when a block from a remote source is accepted, the associated worker must also be created.
  Also noticed some deficienceies in the current setup:
    1. Hashing merkle root as the block hash is wrong. Must include header (not sure how)
    2. timestamp and previous block hash are MISSING! they need to be created. NEXT
    3. How best to represent transactions in the header? What part of them gets hashed?

3/25 Evening
  Proof of work (of sorts) implementeed.
  NEXT: a rake task that can run from cron to create blocks.

3/25 Morning
  Merkle trees implemented. Next step, fill the base of the tree with transactions in block_worker.
  Then do proof of work off the hash, I think.

3/24
  created db tables for blocks and block worker (not yet confirmed or stored blocks) and db-less models merkle_tree and merkle_leaf.
  NEXT: finish merkle_leaf and merkle_tree.
  THEN: PoW

DISCUSSION
  Adding things to the block chain must be done by a reaper that runs on a schedule and can be run in a distributed way, so it can be confirmed by other nodes. So the block model requires a field for number of confirmations and it is not accepted until it is buried by future blocks.
  Interesting point: If transaction volume is low, what do we do? Mining creates a "make work" transaction that also serves a purpose.
  So there is some need for other kinds of transactions. But there's no coin to mine in this context. It doesn't track. What good would the coins be? I gave up the idea of using coins to simulate transaction limits because of the need to replensih daily or more. It doesn't scale well in large or growing organizations, either. Also, mining from mobile devices is disallowed. We want this under tight control.
  A transaction verifying the last block is semi-reasonable.
  Let's start with the basics. Create a block.
    on wake, look for transactions in pool.
    Collect up to n of them
    do the verification.
      When submitting the verification, must first check to see if another one has come in from somewhere. If so, check to see if it's good. If you accept it, fine. If not,
      btw: No transaction is signed in the current implementation. That is not acceptable!
      
      verfiy the proof of work on a block
      Because no block is permanent until verified by some number of 'workers.' And you can't move on the next block without that either.
      Is it possible to have several unverified blocks in the db? NO, because that would mean having several links to transactions.
      So how do we handle an unverified block? How do we have other workers validate it? Do I need to solve that problem now?
      One of the advantages of the blockchain is that every node keeps a full copy. Thus what should happen is that when the blockWorker finds a valid block, it broadasts it to other workers for validation before insertion into the local copy. So the worker that finds the block accepts it but may remove it when other workers refuse it. Assume a minimum of three nodes.
      I am making the current system to work only with one node but multiple nodes are necessary and implied. I'll add that layer later. It could be as simple as having a "pending block" table that can be written to by other systems from time to time. I dunno.

3/22
  Fixed bug concerning failure to store amount.
  I was wrong about images not being stored. They were under ./public/system/payments/invoices/ So I was able to set up image hashes.
  Added simplest possible payment validation.
  NEXT: build and explore the blockchain
  
3/21
  Created project.
  set up user system and transaction save form.
    Payment amount is failing to save.
    I don't think the images are being saved either.
    NEXT: Fix those 2 bugs!
  
Dev plan
  General order of development:
    Create user system  DONE
    create form for inserting images and meta information DONE
    check form data against business rules DONE
    return response DONE
    Insert into blockchain.

  Home page should show recent transactions for this user and their statuses and a submit link.
  Hmmm. That argues for defaulting to transaction index instead of "home"
  NOTE: payments cannot be edited or deleted once they have been added to the blockchain.
  If user is an admin (should create admins), shows them all